<!--
================= AUTOGENERATED FILE =================
================= DO NOT EDIT THIS   =================

If you want to edit this, then change doc/template.README.md instead.

================= DO NOT EDIT THIS   =================
================= AUTOGENERATED FILE =================
-->

# protoCURL

[![Tests Status](https://github.com/qaware/protocurl/actions/workflows/test.yml/badge.svg)](https://github.com/qaware/protocurl/actions/workflows/test.yml)
[![GitHub Release (latest SemVer)](https://img.shields.io/github/v/release/qaware/protocurl?label=Release&logo=GitHub&sort=semver)](https://github.com/qaware/protocurl/releases)
[![DockerHub Version (latest semver)](https://img.shields.io/docker/v/qaware/protocurl?label=Docker&logo=Docker&sort=semver)](https://hub.docker.com/r/qaware/protocurl/tags)

protoCURL is cURL for Protobuf: The command-line tool for interacting with Protobuf over HTTP REST endpoints using
human-readable text formats.

## Install

`protocurl` includes and uses a bundled `protoc` by default. It is recommended to install `curl` into PATH for
configurable http requests. Otherwise `protocurl` will use a simple non-configurable fallback http implementation.

#### Native CLI

1. Download the latest release archive for your platform from https://github.com/qaware/protocurl/releases
2. Extract the archive into a folder, e.g. `/usr/local/protocurl`.
3. Add symlink to the binary in the folder. e.g. `ln -s /usr/local/protocurl/bin/protocurl /usr/local/bin/protocurl`
   Or add the binary folder `/usr/local/protocurl/bin` to your system-wide path.
4. Test that it works via `protocurl -h`

#### Docker

Simply run `docker run -v "/path/to/proto/files:/proto" qaware/protocurl <args>`. See [examples](EXAMPLES.md) below.

## Quick Start

After installing `protocurl` a request is as simple as:

```bash
protocurl -I test/proto -f happyday.proto \
  -i happyday.HappyDayRequest -o happyday.HappyDayResponse \
  -u http://localhost:8080/happy-day/verify -d "includeReason: true"
```

where

* `-I test/proto` points to the directory of protobuf files of your service
    * with docker one needs to instead mount the directory to `/proto` via `-v $PWD/test/proto:/proto`
* `-f happyday.proto` is the path and name to the file containing the request and response message definitions
* `-i happyday.HappyDayRequest` and `-o happyday.HappyDayResponse` are Protobuf package paths to the message types
* `http://localhost:8080/happy-day/verify` is the url to the HTTP REST endpoint accepting and returning binary protobuf
  payloads
    * with docker one may additionally need `--network host`
* `-d '{ includeReason: true }'` is the protobuf payload in Protobuf [Text](#Protobuf Text Format)
  or [JSON](#Protobuf JSON Format) Format

Then protocurl will

* encode the textual Protobuf message to a binary request payload
* send the binary request to the HTTP REST endpoint and receive the binary response payload
* decode the binary response payload back to text and display it

and produce the following output:

```
=========================== Request Text     =========================== >>>
includeReason: true
=========================== Response Text    =========================== <<<
isHappyDay: true
reason: "Thursday is a Happy Day! ⭐"
formattedDate: "Thu, 01 Jan 1970 00:00:00 GMT"
```

See below for usage notes and [EXAMPLES.md](EXAMPLES.md) for more information.

## Usage

```
protocurl <version>, build <hash>, https://github.com/qaware/protocurl

protoCURL is cURL for Protobuf: The command-line tool for interacting with Protobuf over HTTP REST endpoints using human-readable text formats.

Usage:
  protocurl [flags] -f proto-file -i request-type -o response-type -u url -d request-text

It uses 'curl' from PATH. If none was found, it will fall back to an internal non-configurable http request.
It uses a bundled 'protoc' (by default) which is used to parse the .proto files.
The bundle also includes the google protobuf .proto files necessary to create FileDescriptorSet payloads via 'protoc'.
If the bundled 'protoc' is used, then these .proto files are included. Otherwise .proto files from the system-wide include are used.
The Header 'Content-Type: application/x-protobuf' is set as a request header by default.
When converting between binary and text, the encoding UTF-8 is always used.

Bug reports: https://github.com/qaware/protocurl/issues

Examples:
  protocurl -I my-protos -f messages.proto -i package.path.Req -o package.path.Resp -u http://example.com/api -d "myField: true, otherField: 1337"

Flags:
      --curl                      Forces the use of curl executable found in PATH. If none was found, then exits with an error.
  -C, --curl-args string          Additional cURL args which will be passed on to cURL during request invocation for further configuration. Also activates --curl.
      --curl-path string          Uses the given path to invoke curl instead of searching for curl in PATH. Also activates --curl.
  -d, --data-text string          Mandatory: The payload data in Protobuf text format or JSON. It is inferred from the input as JSON if the first token is a '{'. The format can be set explicitly via --in. See https://github.com/qaware/protocurl
  -D, --display-binary-and-http   Displays the binary request and response as well as the non-binary response headers.
  -h, --help                      help for protocurl
      --in string                 Specifies, in which format the input -d should be interpreted in. 'text' (default) uses the Protobuf text format and 'json' uses JSON.
      --no-curl                   Forces the use of the built-in internal http request instead of curl.
      --out string                Produces the output in the specified format. 'text' (default) produces Protobuf text format. 'json' produces dense JSON and 'json:pretty' produces pretty-printed JSON. The produced JSON always uses the original Protobuf field names instead of lowerCamelCasing them.
  -I, --proto-dir string          Uses the specified directory to find the proto-file. (default "/proto")
  -f, --proto-file string         Uses the specified file path to find the Protobuf definition of the message types within 'proto-dir' (relative file path).
      --protoc                    Forces the use of a global protoc executable found in PATH or via --protoc-path instead of using the bundled one. If none was found, then exits with an error.
      --protoc-path string        Uses the given path to invoke protoc instead of searching for protoc in PATH. Also activates --protoc.
  -H, --request-header string     Adds the string header to the invocation of cURL. This option is not supported when --no-curl is active. E.g. -H 'MyHeader: FooBar'.
  -i, --request-type string       Mandatory: Package path of the Protobuf request type. E.g. mypackage.MyRequest
  -o, --response-type string      Mandatory: Package path of the Protobuf response type. E.g. mypackage.MyResponse
  -q, --show-output-only          Suppresses all output except response Protobuf as text. Overrides and deactivates -v and -D. Errors are still printed to stderr.
  -u, --url string                Mandatory: The url to send the request to
  -v, --verbose                   Prints version and enables verbose output. Also activates -D.
      --version                   version for protocurl
```

When you want to link to the usage only, use this: [doc/generated.usage.txt](doc/generated.usage.txt)

## Protobuf JSON Format

protoCURL supports the [Protobuf JSON Format](https://developers.google.com/protocol-buffers/docs/proto3#json). Note,
that the JSON format is not a straightforward 1:1 mapping as it is in the case of the Protobuf Text Format (described
below). For instance,
the [JSON mapping for timestamp.proto](https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/timestamp.proto)
uses a human-readable string representation, whereas the payload itself and the text format use a representation with
seconds and nanoseconds.

## Protobuf Text Format

Aside from JSON, Protobuf primarily and natively supports a text format which represents the fields 1:1 like in the
wire-format. For instance, repeated fields are condensed into an array in the JSON format - whereas they are simply '
repeated' without an array type in the text format.

This text format's syntax
is [barely documented](https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.text_format),
so this section will shortly describe how to write Protobuf messages in the text format.

Given the following .proto file

```
syntax = "proto3";

import "google/protobuf/timestamp.proto";

message HappyDayRequest {
  google.protobuf.Timestamp date = 1;
  bool includeReason = 2;

  double myDouble = 3;
  int64 myInt64 = 5;
  repeated string myString = 6;
  repeated NestedMessage messages = 9;
}

message NestedMessage {
  Foo fooEnum = 1;
  repeated int32 i = 4;
}

enum Foo {
  BAR = 0;
  BAZ = 1;
}
```

A `HappyDayRequest` message in text format might look like this:

```
includeReason: true,
myInt64: 123123123123,
myString: "hello world"
myString: 'single quotes are also possible'
myDouble: 123.456
messages: { fooEnum: BAR, i: 0, i: 1, i: 1337 },
messages: { i: 15, fooEnum: BAZ, i: -1337 },
messages: { },
date: { seconds: 123, nanos: 321 }
```

In summary:

- No encapsulating `{ ... }` are used for the top level message (in contrast to JSON).
- fields are comma separated and described via `<fieldname>: <value>`.
    - Strictly speaking, the commas are optional and whitespace is sufficient
- repeated fields are simply repeated multiple times (instead of using an array) and they do not need to appear
  consecutively.
- nested messages are described with `{ ... }` opening a new context and describing their fields recursively
- scalar values are describes similar to JSON. Single and double quotes are both possible for strings.
- enum values are referenced by their name
- built-in messages (such
  as [google.protobuf.Timestamp](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Timestamp)
  are described just like user-defined custom messages via `{ ... }` and their message fields

[This page shows more details on the text format.](https://stackoverflow.com/a/18877167)

## Development

For development it is recommended to use the a bash-like Terminal either natively (Linux, Mac) or via MinGW on Windows.

About the CI/CD tests: [TESTS.md](TESTS.md)

How to make a release: [RELEASE.md](RELEASE.md)

#### Setup

- As for script utilities, one needs `bash`, `jq`, `zip`, `unzip` and `curl`.
- One also needs to download the protoc binaries for the local development via `release/0-get-protoc-binaries.sh`.

For development the [local.Dockerfile](src/local.Dockerfile) is used. To build the image simply
run `source test/suite/setup.sh` and then `buildProtocurl`

#### Test Server

When new dependencies are needed for the test server, the following command enables one to start a shell in the test
server.

```
docker run -v "$PWD/test/servers:/servers" -it nodeserver:v1 /bin/bash
```

Now it's possible to add new dependencies via `npm install <new-package>`

#### Updating Docs after changes

Generate the main docs (.md files etc.) in bash/WSL via `doc/generate-docs.sh <absolute-path-to-protocurl-repository>`.

Once a pull request is ready, run this to generate updated docs.

## Enhancements and Bugs

See [issues](https://github.com/qaware/protocurl/issues).

## FAQ

- **How is protocurl different from grpccurl?** [grpccurl](https://github.com/fullstorydev/grpcurl) only works with gRPC
  services with corresponding endpoints. However, classic REST HTTP endpoints with binary Protobuf payloads are only
  possible with `protocurl`.
- **Why is the use of a runtime curl recommended with protocurl?** curl is a simple, flexible and mature command line
  tool to interact with HTTP endpoints. In principle, we could simply use the HTTP implementation provided by the host
  programming language (Go) - and this is what we do if no curl was found in the PATH. However, as more people use
  protocurl, they will request for more features - leading to a feature creep in such a 'simple' tool as protocurl. We
  would like to avoid implementing the plentiful features which are necessary for a proper HTTP CLI tool, because HTTP
  can be complex. Since is essentially what curl already does, we recommend using curl and all advanced features are
  only possible with curl.
- **What are some nice features of protocurl?**
    - The implementation is well tested with end-2-end approval tests (see [TESTS.md](TESTS.md)). All features are
      tested based on their effect on the behavior/output. Furthermore, there are also a few cross-platform native CI
      tests running on Windows and MacOS runners.
    - The build and release process is optimised for minimal maintenance efforts. During release build, the latest
      versions of many dependencies are taken automatically (by looking up the release tags via the GitHub API).
    - The documentation and examples are generated via scripts and enable one to update the examples automatically
      rather than manually. The consistency of the outputs of the code with the checked in documentation is further
      tested in CI.
